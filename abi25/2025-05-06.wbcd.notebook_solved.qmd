---
title: "Praktikum zum 06. Mai 2025"
author: M.Sc. Florian Heinke (heinke@hs-mittweida.de)
format:
  html:
    theme: lumen
    code-tools:
      source: false
      toggle: false
      caption: none
    code-block-border-left: "#0069B3"
    code-block-bg: true
    toc-location: left
    toc-depth: 2
    toc: true
    fig-format: svg
df-print: paged
lang: de
---

# Rohdaten-Tabellen einlesen

```{r}
dd_diag <- read.table("data/wbc.diag.txt", sep = "\t", header = TRUE)
head(dd_diag) # print the first 6 lines/elements of a table, matrix or vector or ....

```

```{r}
dd_msmt <- read.table("data/wbc.msmt.txt", sep = "\t", header = T)
head(dd_msmt)
```

# Eine einzige konsistente Datentabelle erzeugen

Das funktioniert scheinbar nicht so einfach:

```{r}
dd_comb <- cbind(dd_diag, dd_msmt)
head(dd_comb)
```

Die `match`-Funktion ist sehr hilfreich.

```{r}
match(dd_diag$id, dd_msmt$id)
```


```{r}
dd_diag$id[1]
dd_msmt$id[129]

dd_msmt$id[509]
dd_diag$id[2]

dd_msmt[c(129, 509, 471),]
dd_diag[1:3,]
```

```{r}
idmatch <- match(dd_diag$id, dd_msmt$id)
```

Nutzen wir diese Indexreihenfolge, um den zweiten Datensatz entsprechend dem ersten zu sortieren.

```{r}
dd_msmt_ordered <- dd_msmt[idmatch,] # ordered according to id list in diagnostics table

# sanity check!!!!!
all( dd_diag$id == dd_msmt_ordered$id)

```

Wir haben ein kleines kosmetisches Problem:

```{r}
dd_comb <- cbind(dd_diag, dd_msmt_ordered)
head(dd_comb)
```

```{r}
dd_comb$id <- NULL
head(dd_comb)

dd_comb2 <- cbind(dd_diag, dd_msmt_ordered[,-1])
head(dd_comb2)
```

# Speichern der Tabelle als `wbcd.tab`

```{r}
write.table(dd_comb2, "data/wbcd.tab", 
            quote = F, 
            row.names = F, 
            sep = "\t")
```

# Erste Gehversuche in der Datenvisualisierung

Nehmen wir an, die Zellen seien kreisförmig im Lichtmikroskopischen Bild. Dann ist der daraus sich ergebende Zellumfang (engl.: *perimeter*, *circumference*) gleich $U = 2\pi R$, wobei $R$ einem Zellradius entspricht. Berechnen wir diese theoretischen Umfänge und legen Sie in einer separaten Spalte namens `peri.circle` ab.

```{r}
dd_comb2$peri.circle <- 2 * pi * dd_comb2$radius

```

Ein einfaches Punktdiagramm zeigt einen interessanten Zusammenhang. Ein Hilfslinie (in blau hinzugefügt mit `abline`) dient der Illustration identischer Wertigkeit:

```{r}
plot(dd_comb2$peri.circle, dd_comb2$perimeter)
abline(a = 0, b = 1, col = 4)
```

Färben wir nach diagnostischem Label (`B - gutartig:` schwarz, `M - bösartig:` rot)

```{r fig.width=5, fig.height=5}
plot(dd_comb2$peri.circle, dd_comb2$perimeter, 
     col  = as.factor(dd_comb2$diagnosis),
     xlab = "Theoretical Circle Perimeter (micrometer)",
     ylab = "Measured Cell Perimeter (micrometer)")
abline(a = 0, b = 1, col = 4)
```

Tragen wir das Umfangsverhältnis, `peri.ratio`, als [Boxplots](https://de.wikipedia.org/wiki/Box-Plot) auf, stratifiziert nach diagnostischem Label:

```{r fig.height=5, fig.width=5}
dd_comb2$peri.ratio <- dd_comb2$perimeter / dd_comb2$peri.circle

dd_benign <- dd_comb2[ dd_comb2$diagnosis == "B",  ]
dd_malign <- dd_comb2[ dd_comb2$diagnosis == "M",  ]

boxplot(dd_benign$peri.ratio,
        dd_malign$peri.ratio,
        names = c("benign", "malignant"),
        col = c(8,2),
        ylab = "perimeter, measured / perimeter, circle")

```

Kleiner Tipp: Es lohnt sich Visualisierungen (mit u.U. mehreren verschiedenen Versionen davon) als Funktionen zu kapseln. Das spart Ihnen fehleranfälliges Code-Kopieren und hält den Code übersichtlich. Das sei im folgenden gezeigt; wir exportieren das Boxplot-Diagramm in verschiedene, beliebte Formate.

```{r}

peri.boxplots.v1 <- function(){
  dd_comb2$peri.ratio <- dd_comb2$perimeter / dd_comb2$peri.circle

  dd_benign <- dd_comb2[ dd_comb2$diagnosis == "B",  ]
  dd_malign <- dd_comb2[ dd_comb2$diagnosis == "M",  ]
  
  boxplot(dd_benign$peri.ratio,
          dd_malign$peri.ratio,
          names = c("benign", "malignant"),
          col = c(8,2),
          ylab = "perimeter, measured / perimeter, circle")
}

```

Exportieren als PNG

```{r}
dir.create("plots")
```

```{r}
png("plots/peri.boxplots.png", width = 500, height = 500)
  peri.boxplots.v1()
dev.off()

```


Exportieren als PDF


```{r}
pdf("plots/peri.boxplots.pdf", width = 5, height = 5)
  peri.boxplots.v1()
dev.off()

```


Exportieren als SVG (scalable vector graphics, editierbar mit externer Software wie z.B. Inkscape)

```{r}
svg("plots/peri.boxplots.svg", width = 5, height = 5)
  peri.boxplots.v1()
dev.off()

```

```{r}
saveRDS( object = dd_comb2, file = "data/wbcd.RDS"  )
```

```{r}
readRDS(file = "data/wbcd.RDS")
```

